let wasm, WASM_VECTOR_LEN = 0, cachegetUint8Memory0 = null; function getUint8Memory0() { return null !== cachegetUint8Memory0 && cachegetUint8Memory0.buffer === wasm.memory.buffer || (cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer)), cachegetUint8Memory0 } let cachedTextEncoder = new TextEncoder("utf-8"); const encodeString = "function" == typeof cachedTextEncoder.encodeInto ? function (e, t) { return cachedTextEncoder.encodeInto(e, t) } : function (e, t) { const n = cachedTextEncoder.encode(e); return t.set(n), { read: e.length, written: n.length } }; function passStringToWasm0(e, t, n) { if (void 0 === n) { const n = cachedTextEncoder.encode(e), a = t(n.length); return getUint8Memory0().subarray(a, a + n.length).set(n), WASM_VECTOR_LEN = n.length, a } let a = e.length, r = t(a); const o = getUint8Memory0(); let c = 0; for (; c < a; c++) { const t = e.charCodeAt(c); if (t > 127) break; o[r + c] = t } if (c !== a) { 0 !== c && (e = e.slice(c)), r = n(r, a, a = c + 3 * e.length); const t = getUint8Memory0().subarray(r + c, r + a); c += encodeString(e, t).written } return WASM_VECTOR_LEN = c, r } let cachegetInt32Memory0 = null; function getInt32Memory0() { return null !== cachegetInt32Memory0 && cachegetInt32Memory0.buffer === wasm.memory.buffer || (cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer)), cachegetInt32Memory0 } let cachedTextDecoder = new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }); function getStringFromWasm0(e, t) { return cachedTextDecoder.decode(getUint8Memory0().subarray(e, e + t)) } cachedTextDecoder.decode(); export function compile_to_cythan(e) { try { const o = wasm.__wbindgen_export_0.value - 16; wasm.__wbindgen_export_0.value = o; var t = passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc), n = WASM_VECTOR_LEN; wasm.compile_to_cythan(o, t, n); var a = getInt32Memory0()[o / 4 + 0], r = getInt32Memory0()[o / 4 + 1]; return getStringFromWasm0(a, r) } finally { wasm.__wbindgen_export_0.value += 16, wasm.__wbindgen_free(a, r) } } export function format_code(e) { try { const o = wasm.__wbindgen_export_0.value - 16; wasm.__wbindgen_export_0.value = o; var t = passStringToWasm0(e, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc), n = WASM_VECTOR_LEN; wasm.format_code(o, t, n); var a = getInt32Memory0()[o / 4 + 0], r = getInt32Memory0()[o / 4 + 1]; return getStringFromWasm0(a, r) } finally { wasm.__wbindgen_export_0.value += 16, wasm.__wbindgen_free(a, r) } } export function start() { wasm.start() } async function load(e, t) { if ("function" == typeof Response && e instanceof Response) { if ("function" == typeof WebAssembly.instantiateStreaming) try { return await WebAssembly.instantiateStreaming(e, t) } catch (t) { if ("application/wasm" == e.headers.get("Content-Type")) throw t; console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", t) } const n = await e.arrayBuffer(); return await WebAssembly.instantiate(n, t) } { const n = await WebAssembly.instantiate(e, t); return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n } } async function init(e) { void 0 === e && (e = import.meta.url.replace(/\.js$/, "_bg.wasm")); ("string" == typeof e || "function" == typeof Request && e instanceof Request || "function" == typeof URL && e instanceof URL) && (e = fetch(e)); const { instance: t, module: n } = await load(await e, {}); return wasm = t.exports, init.__wbindgen_wasm_module = n, wasm.__wbindgen_start(), wasm } export default init;